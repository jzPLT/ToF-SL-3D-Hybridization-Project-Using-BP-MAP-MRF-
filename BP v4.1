/*
Copyright (C) 2006 Pedro Felzenszwalb

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
*/


#include <cstdio>

#include <iostream>

#include <algorithm>

#include <assert.h>

#include <cstring>
#include <vector>

#include "image.h"

#include "misc.h"

#include "pnmfile.h"


#define ITER 5       // number of BP iterations at each scale

#define LEVELS 1     // number of scales


#define DISC_K 200.0F       // truncation of discontinuity cost

#define DATA_K 10000.0F     // truncation of data cost

#define LAMBDA 0.05F         // weighting of data cost


#define INF 1E10     // large cost

#define VALUES 256   // number of possible graylevel values

#define TWIDTH 7	// Width of tile
#define THEIGHT 7	// Height of tile


// dt of 1d function

static float *dt(float *f, int n) {
  
	float *d = new float[n];
  
	int *v = new int[n];
  
	float *z = new float[n+1];
  
	int k = 0;
  
	v[0] = 0;
  
	z[0] = -INF;
  
	z[1] = +INF;

  
	for (int q = 1; q <= n-1; q++) 
	   {
    float s  = ((f[q]+square(q))-(f[v[k]]+square(v[k]))) / (2*(q-v[k]));
    
		while (s <= z[k]) 
		{
      k--;
      
			s  = ((f[q]+square(q))-(f[v[k]]+square(v[k]))) / (2*(q-v[k]));
    
		}
    
		k++;
    
		v[k] = q;
    
		z[k] = s;
    
		z[k+1] = +INF;
  
	   }
  
	k = 0;
  
	for (int q = 0; q <= n-1; q++) 
	{
    while (z[k+1] < q)
      
		k++;
    
	     d[q] = square(q-v[k]) + f[v[k]];
  
	}
  
	delete [] v;
  
	delete [] z;
  
	return d;

}


// compute message
void msg(float s1[VALUES], float s2[VALUES], float s3[VALUES], float s4[VALUES],
 float dst[VALUES]) {
 
// aggregate and find min
float minimum = INF;
  
for (int value = 0; value < VALUES; value++) {
	dst[value] = s1[value] + s2[value] + s3[value] + s4[value];
    if (dst[value] < minimum)
      minimum = dst[value];
  }

// dt
  float *tmp = dt(dst, VALUES);

  // truncate and store in destination vector
  minimum += DISC_K;
  for (int value = 0; value < VALUES; value++)
    dst[value] = std::min(tmp[value], minimum);

  // normalize
  float val = 0;
  for (int value = 0; value < VALUES; value++) 
    val += dst[value];

  val /= VALUES;
  for (int value = 0; value < VALUES; value++) 
    dst[value] -= val;

  delete tmp;
}

void msgCor(float s1[VALUES], float s2[VALUES], float s3[VALUES], 
	float dst[VALUES]) {

	// aggregate and find min
	float minimum = INF;

	for (int value = 0; value < VALUES; value++) {
		dst[value] = s1[value] + s2[value] + s3[value];
		if (dst[value] < minimum)
			minimum = dst[value];
	}

	// dt
	float *tmp = dt(dst, VALUES);

	// truncate and store in destination vector
	minimum += DISC_K;
	for (int value = 0; value < VALUES; value++)
		dst[value] = std::min(tmp[value], minimum);

	// normalize
	float val = 0;
	for (int value = 0; value < VALUES; value++)
		val += dst[value];

	val /= VALUES;
	for (int value = 0; value < VALUES; value++)
		dst[value] -= val;

	delete tmp;
}

// computation of data costs
image<float[VALUES]> *comp_data(image<uchar> *img) {
  int width = img->width();
  int height = img->height();
  image<float[VALUES]> *data = new image<float[VALUES]>(width, height);

  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++) {
      for (int value = 0; value < VALUES; value++) {
	float val = square((float)(imRef(img, x, y)-value));
	imRef(data, x, y)[value] = LAMBDA * std::min(val, DATA_K);
      }
    }
  }

  return data;
}

// generate output from current messages
image<uchar> *output(image<float[VALUES]> *u, image<float[VALUES]> *d, 
		     image<float[VALUES]> *l, image<float[VALUES]> *r, 
		     image<float[VALUES]> *data) {
  int width = data->width();
  int height = data->height();
  image<uchar> *out = new image<uchar>(width, height);

  for (int y = 1; y < height-1; y++) {
    for (int x = 1; x < width-1; x++) {
      // keep track of best value for current pixel
      int best = 0;
      float best_val = INF;
      for (int value = 0; value < VALUES; value++) {
	float val = 
	  imRef(u, x, y+1)[value] +
	  imRef(d, x, y-1)[value] +
	  imRef(l, x+1, y)[value] +
	  imRef(r, x-1, y)[value] +
	  imRef(data, x, y)[value];
	if (val < best_val) {
	  best_val = val;
	  best = value;
	}
      }
      imRef(out, x, y) = best;
    }
  }

  return out;
}

// belief propagation using checkerboard update scheme
void bp_cb(image<float[VALUES]> *u, image<float[VALUES]> *d,
	   image<float[VALUES]> *l, image<float[VALUES]> *r,
	   image<float[VALUES]> *data,
	   int iter) {
  int width = data->width();  
  int height = data->height();

  for (int t = 0; t < ITER; t++) {
    std::cout << "iter " << t << "\n";

    for (int y = 1; y < height-1; y++) {
      for (int x = ((y+t) % 2) + 1; x < width-1; x+=2) {
	msg(imRef(u, x, y+1),imRef(l, x+1, y),imRef(r, x-1, y),
	    imRef(data, x, y), imRef(u, x, y));

	msg(imRef(d, x, y-1),imRef(l, x+1, y),imRef(r, x-1, y),
	    imRef(data, x, y), imRef(d, x, y));

	msg(imRef(u, x, y+1),imRef(d, x, y-1),imRef(r, x-1, y),
	    imRef(data, x, y), imRef(r, x, y));

	msg(imRef(u, x, y+1),imRef(d, x, y-1),imRef(l, x+1, y),
	    imRef(data, x, y), imRef(l, x, y));
      }
    }
  }
}

// multiscale belief propagation for image restoration
image<uchar> *restore_ms(image<uchar> *img) {


	//image<float[VALUES]> *data;
	//image<uchar> * tiles;

	//Data costs
	//data = comp_data(img);
	// BP
	//bp_cb(u, d, l, r, data, ITER);    

	int width = img->width();
	int height = img->height();
	// Number of tiles in each direction ignores the outer ring
	//Number of tiles in the image
	int numRowTiles = (((width - 2) / TWIDTH) + 1);
	int numColTiles = (((height - 2) / THEIGHT) + 1);
	// Remaining number of rows/cols in last tile
	int remRows = width-2 - ((numRowTiles - 1)*TWIDTH);
	int remCols = height-2 - ((numColTiles - 1)*THEIGHT);

	// The actual width and height of the tile
	image<int> *wTile, *hTile;

	// the tile image splits the image object into several image objects with width <= TWIDTH
	image<image<uchar>> *tile = new image<image<uchar>>(numRowTiles, numColTiles);

	wTile = new image<int>(numRowTiles, 1);
	hTile = new image<int>(numColTiles, 1);

	int cumTileWidth = 0, cumTileHeight = 0;

	for (int q = 0; q < numColTiles; q++) {
		if (q == 0 || q == numColTiles - 1) imRef(hTile, q, 0) = 1;
		else if (q == numColTiles - 2) imRef(hTile, q, 0) = remCols;
		else imRef(hTile, q, 0) = THEIGHT;

		std::cout << "Row: " << imRef(hTile, q, 0);
		std::cout << ("\n");

		for (int p = 0; p < numRowTiles; p++) {


			if (p == 0 || p == numRowTiles - 1) imRef(wTile, p, 0) = 1;
			else if (p == numRowTiles - 2) imRef(wTile, p, 0) = remRows;
			else imRef(wTile, p, 0) = TWIDTH;

			//std::cout << "Row: " << imRef(wTile, p, 0);
			//std::cout << ("\n");

			cumTileWidth += imRef(wTile, p, 0);

			// the rawTile image splits each tile image objects into image objects that receive raw pixel data.
			image<uchar> *rawTile = new image<uchar>(imRef(wTile, p, 0), imRef(hTile, q, 0));

			for (int r = 0; r < imRef(hTile, q, 0); r++) {
				
				// The image row/col corresponding to the tile pixel location
				int imgCol = cumTileHeight + r;
				for (int s = 0; s < imRef(wTile, p, 0); s++) {

					// The image row/col corresponding to the tile pixel location
					int imgRow = cumTileWidth + s;

					imRef(rawTile, s, r) = imRef(img, imgRow, imgCol);
				}
			}
			imRef(tile, p, q) = *rawTile;

			//delete rawTile;

		}

		cumTileHeight += imRef(hTile, q, 0);
		cumTileWidth = 0;
	}
	
	image<float[VALUES]> *data = new image<float[VALUES]>(width, height);
	image<float[VALUES]> *uBound;
	image<float[VALUES]> *dBound;
	image<float[VALUES]> *lBound;
	image<float[VALUES]> *rBound;
	image<float[VALUES]> *u;
	image<float[VALUES]> *d;
	image<float[VALUES]> *l;
	image<float[VALUES]> *r;

	for (int y = 0; y < height; y++) {
		for (int x = 0; x < width; x++) {
			for (int value = 0; value < VALUES; value++) {
				float val = square((float)(imRef(img, x, y) - value));
				imRef(data, x, y)[value] = LAMBDA * std::min(val, DATA_K);
			}
		}
	}

	//std::vector<std::array<float,NULL> >;

	for (int t1 = 0; t1 < ITER; t1++) {
		std::cout << "iter " << t1 << "\n";

		uBound = new image<float[VALUES]>(width, numColTiles, false);
		dBound = new image<float[VALUES]>(width, numColTiles, false);
		lBound = new image<float[VALUES]>(numRowTiles, height, false);
		rBound = new image<float[VALUES]>(numRowTiles, height, false);
		for (int col = 1; col < numColTiles-1; col++) {
			for (int row = 1; row < numRowTiles-1; row++) {

				u = new image<float[VALUES]>(imRef(wTile, row, 0), imRef(hTile, col, 0), false);
				d = new image<float[VALUES]>(imRef(wTile, row, 0), imRef(hTile, col, 0), false);
				l = new image<float[VALUES]>(imRef(wTile, row, 0), imRef(hTile, col, 0), false);
				r = new image<float[VALUES]>(imRef(wTile, row, 0), imRef(hTile, col, 0), false);
				for (int t0 = 0; t0 < ITER; t0++) {
					for (int y = 0; y < imRef(hTile, col, 0); y++) {
						for (int x = ((y + t0) % 2); x < imRef(wTile, row, 0); x += 2) {
							if (t0 == 0) {
								if (x == 0 && y != 0 && y != (imRef(hTile, col, 0) - 1)) {
									std::cout << imRef(r, x - 1, y) << "\n" << imRef(rBound, row - 1, col);
									imRef(r, x - 1, y) = imRef(rBound, row - 1, col);
								}

								//Edges
								if (x == 0 && y != 0 && y != (imRef(hTile, col, 0) - 1)) {
								//if (x == 0 && (0 < y < imRef(hTile, col, 0) - 1)) {

									msg(imRef(u, x, y + 1), imRef(l, x + 1, y), imRef(rBound, row-1, col),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(d, x, y - 1), imRef(l, x + 1, y), imRef(rBound, row-1, col),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(rBound, row-1, col),
										imRef(data, x, y), imRef(r, x, y));
								}
								else if ((x == imRef(wTile, col, 0) - 1) && 
										y != 0 && y != (imRef(hTile, col, 0) - 1)) {
									msg(imRef(u, x, y + 1), imRef(lBound, row + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(d, x, y - 1), imRef(lBound, row + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(lBound, row + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}

								else if (x!=0 &&  x != imRef(wTile, col, 0) - 1 && y == 0) {

									msg(imRef(dBound, row, col - 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(dBound, row, col - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(r, x, y));

									msg(imRef(u, x, y + 1), imRef(dBound, row, col - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}
								else if (x != 0 && x != imRef(wTile, col, 0) - 1 && y == imRef(hTile, col, 0) - 1) {

									msg(imRef(uBound, row, col + 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(uBound, row, col + 1), imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(r, x, y));

									msg(imRef(uBound, row, col + 1), imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}

								//Corners
								else if (x == imRef(wTile, col, 0) - 1 && y == imRef(hTile, col, 0) - 1) {
									msg(imRef(uBound, row, col + 1), imRef(lBound, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(uBound, row, col + 1), imRef(lBound, x + 1, y), imRef(d, x, y - 1),
										imRef(data, x, y), imRef(l, x, y));
								}
								else if (x == 0 && y == imRef(hTile, col, 0) - 1) {

									msg(imRef(uBound, row, col + 1), imRef(l, x + 1, y), imRef(rBound, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(d, x, y - 1), imRef(uBound, row, col + 1), imRef(rBound, x - 1, y),
										imRef(data, x, y), imRef(r, x, y));
								}
								else if (x == imRef(wTile, col, 0) - 1 && y == 0) {

									msg(imRef(dBound, row, col - 1), imRef(r, x - 1, y), imRef(lBound, x + 1, y),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(dBound, row, col - 1), imRef(lBound, x + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}
								else if (x == 0 && y == 0) {

									msg(imRef(dBound, row, col - 1), imRef(l, x + 1, y), imRef(rBound, row - 1, col),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(dBound, row, col - 1), imRef(rBound, row - 1, col),
										imRef(data, x, y), imRef(r, x, y));
								}

								else {
									msg(imRef(u, x, y + 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(d, x, y - 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(r, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}
							}
							else if (t0 == ITER - 1) {
								//Edges
								if (x == 0 && y != 0 && y != (imRef(hTile, col, 0) - 1)) {
									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(lBound, row, col));
								}
								else if ((x == imRef(wTile, col, 0) - 1) && 
										y != 0 && y != (imRef(hTile, col, 0) - 1)) {
									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(rBound, row, col));
								}

								else if (x != 0 && x != imRef(wTile, col, 0) - 1 && y == 0) {
									msg(imRef(u, x, y + 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(uBound, row, col));
								}
								else if (x != 0 && x != imRef(wTile, col, 0) - 1 && y == imRef(hTile, col, 0) - 1) {
									msg(imRef(d, x, y - 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(dBound, row, col));
								}

								//Corners
								else if (x == imRef(wTile, col, 0) - 1 && y == imRef(hTile, col, 0) - 1) {
									msgCor(imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(rBound, row, col));

									msgCor(imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(dBound, row, col));
								}
								else if (x == 0 && y == imRef(hTile, col, 0) - 1) {

									msgCor(imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(lBound, row, col));

									msgCor(imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(dBound, row, col));
								}
								else if (x == imRef(wTile, col, 0) - 1 && y == 0) {

									msgCor(imRef(u, x, y + 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(uBound, row, col));

									msgCor(imRef(u, x, y + 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(rBound, row, col));
								}
								else if (x == 0 && y == 0) {

									msgCor(imRef(u, x, y + 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(lBound, row, col));

									msgCor(imRef(u, x, y + 1), imRef(l, x + 1, y), 
										imRef(data, x, y), imRef(uBound, row, col));
								}

								else {
									msg(imRef(u, x, y + 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(u, x, y));

									msg(imRef(d, x, y - 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(d, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(r, x - 1, y),
										imRef(data, x, y), imRef(r, x, y));

									msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(l, x + 1, y),
										imRef(data, x, y), imRef(l, x, y));
								}

							}
							else {
								
							}
							/*msg(imRef(u, x, y + 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
								imRef(data, x, y), imRef(u, x, y));

							msg(imRef(d, x, y - 1), imRef(l, x + 1, y), imRef(r, x - 1, y),
								imRef(data, x, y), imRef(d, x, y));

							msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(r, x - 1, y),
								imRef(data, x, y), imRef(r, x, y));

							msg(imRef(u, x, y + 1), imRef(d, x, y - 1), imRef(l, x + 1, y),
								imRef(data, x, y), imRef(l, x, y));*/

						}
					}
				}

				delete u;
				delete d;
				delete l;
				delete r;
			}
		}

		std::cout << "End of loop";

		delete uBound;
		delete dBound;
		delete rBound;
		delete lBound;
	}

	u = new image<float[VALUES]>(2,2, false);
	d = new image<float[VALUES]>(2, 2, false);
	l = new image<float[VALUES]>(2, 2, false);
	r = new image<float[VALUES]>(2, 2, false);

	image<uchar> *out = output(u, d, l, r, data);
	delete u;
	delete d;
	delete l;
	delete r;
	delete data;
	delete[] tile;

	return out;
}

int main(int argc, char **argv) {
  image<uchar> *img, *out, *edges;

 if (argc != 3) {
    std::cerr << "usage: " << argv[0] << " in(pgm) out(pgm)\n";
    exit(1);
  }
 

  // load input
  img = loadPGM(argv[1]);

  // restore
  out = restore_ms(img);

  // save output
  savePGM(out, argv[2]);
  
  delete img;
  delete out;
  return 0;
}
